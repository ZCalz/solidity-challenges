// SPDX-License-Identifier: MIT
pragma solidity ^0.8.15;

import "@openzeppelin/contracts/utils/math/Math.sol";

contract WeightedVoting {
    mapping(address => uint256) public balances;
    mapping(address => uint256) public votingWeight;
    uint256 public totalAmountContrubuted;
    address[] public voters;
    bool public allowVoting;
    uint256 public votingBlock;

    mapping(address => bool) public voted;

    constructor(uint256 startVotingAt) {
        votingBlock = block.number + startVotingAt;
    }

    function contributeWeight() external payable {
        require(allowVoting == false, "Cannot contribute while voting is in session");
        require(msg.value > 0, "Must contribute greater than 0");
        if (balances[msg.sender] == 0) {
            voters.push(msg.sender);  
        }
        balances[msg.sender] += msg.value;
        totalAmountContrubuted += msg.value;
    }

    function recordWeightAndRefundBalances() external {
        require(block.number >= votingBlock, "Cannot record vote weight until votingBlock block height.");
        for (uint256 i = 0; i < voters.length; i++) {
            address user = voters[i];
            uint256 amount = balances[user];
            
            votingWeight[user] = Math.mulDiv(amount, 100, totalAmountContrubuted); // (amount / totalAmountContrubuted) * 100;
            if (amount > 0) {
                
                (bool success, ) = user.call{value: amount}("");  
                if (!success) {
                    revert("Transfer failed");  
                }

                balances[user] = 0; 
            }
        }
        allowVoting = true;
    }

    function vote() external {
        require(allowVoting == true, "Cannot vote yet");
        require(votingWeight[msg.sender] > 0, "Voter must have assigned weight");
        voted[msg.sender] = true;
    }

    /// ---- Additional functions for determining and calculating winning vote based on weight etc. --- /// no neccessary for exploit to occur
}
